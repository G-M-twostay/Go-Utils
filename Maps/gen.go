//go:build ignore

package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

func newImplR(typeName, fTypeName string) *strings.Replacer {
	return strings.NewReplacer(
		"~uintptr | ~uint | ~int", "~"+typeName,
		".LoadUintptr", ".Load"+fTypeName,
		".StoreUintptr", ".Store"+fTypeName,
		".SwapUintptr", ".Swap"+fTypeName,
		".CompareAndSwapUintptr", ".CompareAndSwap"+fTypeName,
		"NewValUintptr", "NewVal"+fTypeName,
		"ValUintptr", "Val"+fTypeName,
		"valNode[K, uintptr]", "valNode[K, "+typeName+"]",
		"uintptr /*typeCast*/", typeName,
	)
}
func newTestR(typeName, fTypeName string) *strings.Replacer {
	return strings.NewReplacer(
		"TestValUintptr_", "TestVal"+fTypeName+"_",
		"testVUintptrT uintptr", fmt.Sprintf("testV%sT %s", fTypeName, typeName),
		"NewValUintptr", "NewVal"+fTypeName,
		"testVUintptrT", fmt.Sprintf("testV%sT", fTypeName),
	)
}

var (
	implTmplPath, testTmplPath string
)

func init() {
	flag.StringVar(&implTmplPath, "implTmpl", "", "implementation template file path")
	flag.StringVar(&testTmplPath, "testTmpl", "", "test template file path")
}

const (
	header = `// Code generated by go generate; DO NOT EDIT.
// Generated specializations of ValVal maps that exhausts atomicXXX functions based on ValUintptr.go and ValUintptr_test.go.
`
)

func main() {
	wd, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	flag.Parse()
	implTmplPath = filepath.Join(wd, implTmplPath)
	testTmplPath = filepath.Join(wd, testTmplPath)

	implTmpl, err := os.ReadFile(implTmplPath)
	if err != nil {
		panic(err)
	}
	testTmpl, err := os.ReadFile(testTmplPath)
	if err != nil {
		panic(err)
	}

	for _, tn := range flag.Args() {
		ftn := strings.ToUpper(tn[:1]) + tn[1:]

		genImpl, err := os.OpenFile(filepath.Join(wd, "Val"+ftn+".go"), os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
		if err != nil {
			panic(err)
		}
		genTest, err := os.OpenFile(filepath.Join(wd, "Val"+ftn+"_test.go"), os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
		if err != nil {
			panic(err)
		}

		if _, err = genImpl.WriteString(header); err != nil {
			panic(err)
		}
		if _, err = genTest.WriteString(header); err != nil {
			panic(err)
		}

		implR, testR := newImplR(tn, ftn), newTestR(tn, ftn)
		if _, err = implR.WriteString(genImpl, string(implTmpl)); err != nil {
			panic(err)
		}
		if _, err = testR.WriteString(genTest, string(testTmpl)); err != nil {
			panic(err)
		}

		genImpl.Close()
		genTest.Close()
	}
}
