package main

import (
	"flag"
	"os"
	"strings"
)

func newImplR(typeName, fTypeName string) *strings.Replacer {
	return strings.NewReplacer(
		"~uintptr | ~uint | ~int", "~"+typeName,
		".LoadUintptr", ".Load"+fTypeName,
		".StoreUintptr", ".Store"+fTypeName,
		".SwapUintptr", ".Swap"+fTypeName,
		".CompareAndSwapUintptr", ".CompareAndSwap"+fTypeName,
		"NewValUintptr", "NewVal"+fTypeName,
		"ValUintptr", "Val"+fTypeName,
		"valNode[K, uintptr]", "valNode[K, "+typeName+"]",
		"uintptr(", typeName+"(",
	)
}
func newTestR(typeName, fTypeName string) *strings.Replacer {
	return strings.NewReplacer(
		"TestValUintptr_", "TestVal"+fTypeName+"_",
		"testVUintptrT uintptr", "testVUintptrT "+typeName,
		"NewValUintptr", "NewVal"+fTypeName,
	)
}

var (
	implTmplPath, testTmplPath, genImplPath, genTestPath string
)

func init() {
	flag.StringVar(&implTmplPath, "implTmpl", "", "implementation template file path")
	flag.StringVar(&testTmplPath, "testTmpl", "", "test template file path")
	flag.StringVar(&genImplPath, "genImpl", "generated.go", "generated implementation file path")
	flag.StringVar(&genTestPath, "genTest", "generated_test.go", "generated test file path")
}

const HEADER = `
// Code generated by go generate; DO NOT EDIT.
package v2
// Generated specializations of ValVal maps that exhausts atomicXXX functions based on ValUintptr.go.`

func main() {
	flag.Parse()
	implTmpl, err := os.ReadFile(implTmplPath)
	if err != nil {
		panic(err)
	}
	testTmpl, err := os.ReadFile(testTmplPath)
	if err != nil {
		panic(err)
	}
	genImpl, err := os.OpenFile(genImplPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		panic(err)
	}
	defer genImpl.Close()
	genTest, err := os.OpenFile(genTestPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		panic(err)
	}
	defer genTest.Close()

	if _, err = genImpl.WriteString(HEADER); err != nil {
		return
	}
	if _, err = genTest.WriteString(HEADER); err != nil {
		return
	}
	for _, tn := range flag.Args() {
		ftn := strings.ToUpper(tn[:1]) + tn[1:]
		implR, testR := newImplR(tn, ftn), newTestR(tn, ftn)
		if _, err = implR.WriteString(genImpl, string(implTmpl)); err != nil {
			panic(err)
		}
		if _, err = testR.WriteString(genTest, string(testTmpl)); err != nil {
			panic(err)
		}
	}
}
